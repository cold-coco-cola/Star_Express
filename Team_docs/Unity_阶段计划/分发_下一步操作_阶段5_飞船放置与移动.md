# 分发给任务负责人 — 下一步操作：阶段 5（飞船放置与移动）

> **适用对象**：负责「飞船放置与移动」的操作任务负责人。  
> **前置条件**：阶段 4 已完成（连线与延伸、LineManager、LineRenderer、选色面板）。  
> **对应计划**：[星穹铁道实现计划] 阶段 5。  
> **依据**：技术文档 §4.4、§5.2、PRD §4.4。

---

## 本步目标与验收

**目标**：在航线上放置飞船，飞船沿线路往返移动，到站停靠 1 秒后继续；本阶段**不实现载客/卸客**，资源扣减留阶段 9。

**验收**（计划原文）：

- 能在太阳–水星线上放置飞船，飞船往返移动，到站停 1 秒后继续。

**资源需求**：无。飞船 Sprite 可从 VisualConfig.shipSprite 取，或占位；资源扣减本阶段不做。

---

## 一、创建 ShipBehaviour（计划任务 1）

### 1.1 职责与放置位置

- **职责**：持有 line、capacity、passengers、currentSegmentIndex、direction、progressOnSegment、state、dockRemainingTime；每帧更新位置（Moving 时插值）或停靠倒计时（Docked 时）；到站进入 Docked、停靠 1 秒后离站，端点调头。
- **放置**：`Assets/Game/脚本/Entities/ShipBehaviour.cs`。

### 1.2 建议字段（技术文档 §4.4、PRD §4.4）

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | string | 唯一标识，如 "Ship_0"，便于多船同站排序 |
| line | Line | 所属航线，由放置时注入 |
| capacity | int | 最大载客数，从 GameBalance 取，本阶段可写死 4 |
| passengers | List&lt;PassengerBehaviour&gt; | 当前载客，本阶段可空列表 |
| currentSegmentIndex | int | 当前段在 line.stationSequence 中的索引，即 [i, i+1] |
| direction | int | 1=正向，-1=反向；到端点调头 |
| progressOnSegment | float | 当前段上的插值，0=起点站，1=终点站 |
| state | enum | Moving / Docked |
| dockRemainingTime | float | 停靠剩余秒数，Docked 时每帧减去 deltaTime |

**speed、dockDuration**：从 GameBalance 读取（shipSpeedUnitsPerSecond、dockDurationSeconds），或在 Awake/Start 中从 GameManager 取 GameBalance 引用。

### 1.3 移动计算（技术文档 §4.4）

- **Moving**：  
  - 当前段两端：`stationA = line.stationSequence[currentSegmentIndex]`，`stationB = line.stationSequence[currentSegmentIndex + 1]`。  
  - `segmentLength = Vector2.Distance(stationA.transform.position, stationB.transform.position)`。  
  - `progressOnSegment += direction * speed * Time.deltaTime / segmentLength`。  
  - 若 `progressOnSegment >= 1`：到达终点站，进入 Docked，当前站 = stationB，dockRemainingTime = 停靠时间，currentSegmentIndex 可先不变（离站时再切段）。  
  - 若 `progressOnSegment <= 0`：到达起点站，进入 Docked，当前站 = stationA，同上。  
- **位置**：每帧 `transform.position = Vector3.Lerp(stationA.position, stationB.position, progressOnSegment)`（或 Vector2 转 Vector3，z 固定）。

### 1.4 停靠与离站（计划任务 4）

- **Docked**：每帧 `dockRemainingTime -= Time.deltaTime`。  
- 当 `dockRemainingTime <= 0`：  
  - 若当前站为 **端点**（currentSegmentIndex==0 或 currentSegmentIndex==stationSequence.Count-2）：`direction *= -1`。  
  - 若 direction 为 1：下一段为 currentSegmentIndex+1，progressOnSegment = 0；若 direction 为 -1：下一段为 currentSegmentIndex-1，progressOnSegment = 1。更新 currentSegmentIndex 后 state = Moving。  
  - 若已是端点且只有一段（仅两站），则调头后 currentSegmentIndex 仍为 0，progressOnSegment 置 0，沿原段反向。

### 1.5 本阶段不实现

- 载客/卸客：进入 Docked 时**不**调用 BoardingController，仅做倒计时与离站。

### 1.6 操作步骤

1. 在 **Scripts/Entities** 下创建 **ShipBehaviour**，继承 MonoBehaviour。
2. 声明上述字段；在 **Update** 中：state==Moving 时按 1.3 更新 progressOnSegment 与 position，到达 0 或 1 时转 Docked 并设 dockRemainingTime；state==Docked 时扣减 dockRemainingTime，到 0 时按 1.4 离站并可能调头。
3. 从 GameBalance 取 speed、dockDuration（通过 GameManager 或序列化引用）。
4. 保存，编译通过。

---

## 二、创建或完善 Ship.prefab（计划任务 2）

### 2.1 结构（技术文档 §4.4、03_Prefab与组件）

- **根节点**：**Ship**；挂 **ShipBehaviour**、**Circle Collider 2D**（半径略大于显示，便于后续点击放置客舱）。
- **子节点 Visual**：**SpriteRenderer**；Sprite 从 VisualConfig.shipSprite 取（可在 ShipBehaviour.Start 中根据 line.color 与 VisualConfig 设 Sprite 与 color）。

### 2.2 操作步骤

1. 若已有 03 中的 Ship.prefab：在根上添加 **ShipBehaviour**；在 ShipBehaviour 中于 Start 或由外部注入 line 后，从 VisualConfig 取 shipSprite 赋给 Visual 的 SpriteRenderer，并设 `SpriteRenderer.color = VisualConfig.lineColors[(int)line.color]`（或按项目 LineColor 映射）。
2. 若未创建：Hierarchy 建空物体 Ship → 添加 Circle Collider 2D、ShipBehaviour → 子节点 Visual 添加 Sprite Renderer → 拖到 _Project/Prefabs 生成 Ship.prefab。
3. Prefab 根 position 可为 (0,0,0)；运行时由放置逻辑设到 line 起点，之后每帧由 ShipBehaviour 更新。
4. 保存 Prefab。

---

## 三、放置飞船入口（计划任务 6）

### 3.1 放置逻辑

- **前置**：存在至少一条 Line 且 stationSequence.Count >= 2；本阶段**不扣减** shipCount，仅生成飞船。
- **操作**：玩家通过「点击某条 Line」或「简单 UI 按钮选择线后确认」触发放置。在 Line 上生成一艘 Ship：实例化 Ship.prefab，设 line、id（如 Ship_0）、currentSegmentIndex=0、direction=1、progressOnSegment=0、state=Moving、position=line.stationSequence[0].transform.position；将 Ship 加入 line.ships；将 Ship 实例挂到场景 **Ships** 根节点下。

### 3.2 点击 Line 检测（技术文档 §10.2）

- 若采用「点击 Line 放置」：需能检测到玩家点击的是哪条 Line。可选方式：  
  - 为每条 Line 的视觉 GameObject 添加 **EdgeCollider2D** 或沿线段的多段 **Collider2D**，射线检测后根据 hit 的 GameObject 反查所属 Line；  
  - 或不用 Collider，用射线与各 Line 的线段做「点到线段距离」，取最近的一条 Line。
- 若采用「简单 UI 按钮」：下拉或按钮列出当前所有 Line（如按 id），选一条后确认即在该 Line 上放置一艘船；无需射线检测 Line。

### 3.3 放置入口由谁提供

- **LineManager** 可提供方法：`public ShipBehaviour SpawnShip(Line line)`：创建 Ship 实例、设 line/id/currentSegmentIndex/direction/progressOnSegment/state、加入 line.ships、挂到 Ships 根下、返回 ShipBehaviour。  
- 调用方：临时 UI 按钮脚本，或 **ResourcePlacementInput** 占位（本阶段仅「点击 Line」或「选 Line 按钮」时调用 LineManager.SpawnShip，不扣资源）。

### 3.4 操作步骤

1. 在 LineManager 或 GameManager 中实现 **SpawnShip(Line line)**：Instantiate(ShipPrefab)、设父节点为 Ships、注入 line 与 id、加入 line.ships、初始 position 为 stationSequence[0].position。
2. 实现放置入口：简单 UI 按钮（选一条线后调用 SpawnShip），或点击 Line 检测后调用 SpawnShip；本阶段不扣减 shipCount。
3. 保存，编译通过。

---

## 四、移动与停靠联调（计划任务 3、4、5）

### 4.1 检查项

- 放置后飞船出现在 line 的起点（stationSequence[0]），并沿线段向 stationSequence[1] 移动。
- 到达终点站后进入 Docked，停靠约 1 秒后离站；若为两站线则调头回到起点站，再停靠 1 秒再调头，循环。
- 若为三站及以上：到末端调头，到首端再调头，中间站停靠 1 秒后继续下一段（不调头）。
- 本阶段不执行载客/卸客，仅移动与停靠节奏正确即可。

### 4.2 操作步骤

1. 运行场景，建一条太阳–水星线（或太阳–水星–金星），放置一艘飞船。
2. 确认飞船往返移动、到站停 1 秒、端点调头；无报错。
3. 若有多个站点，确认中间站停靠后沿下一段继续、端点调头逻辑正确。

---

## 五、执行后自检（交回前必做）

请逐项勾选后交付：

- [ ] **ShipBehaviour**：含 line、capacity、passengers、currentSegmentIndex、direction、progressOnSegment、state、dockRemainingTime；Moving 时按段插值更新位置，到 0/1 转 Docked；Docked 倒计时结束后离站，端点调头。
- [ ] **Ship.prefab**：根 ShipBehaviour + Collider2D，子 Visual（SpriteRenderer）；Visual 从 VisualConfig 取 shipSprite 并按 line.color 着色；位于 _Project/Prefabs。
- [ ] **放置**：能在某条 Line 上放置飞船（按钮或点击 Line）；飞船出现在起点并加入 line.ships；本阶段不扣减资源。
- [ ] **验收**：太阳–水星线上放置飞船后，飞船往返移动，到站停 1 秒后继续。
- [ ] 本阶段未实现载客/卸客；控制台无报错。

---

## 六、参考与衔接

- **移动公式**：技术文档 §4.4、PRD §4.4。
- **Line 与 stationSequence**：阶段 4 的 Line 数据类与 LineManager。
- **后续阶段**：阶段 7 在 Ship 进入 Docked 时调用 BoardingController 卸客/载客；阶段 9 放置飞船时扣减 shipCount。

---

*文档结束。请按一～四顺序执行，自检全部勾选后交付。*
